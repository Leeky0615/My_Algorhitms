'''
    그리디 알고리즘 (탐욕법)
     현재 상황에서 지금 당장 좋은 것만 고르는 방법
     일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는
     능력을 요구한다.
     크루스카, 다이스트 최단 경로등 잘 알려진 알고리즘을 제외하고 일반적으로
     그리디 알고리즘이 출제되면 해당 문제를 풀기위한 적절한 알고리즘을 떠올려야 문제를
     풀수있다
     단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다.
      -> 문제에서 요구하는 최적의 해를 찾을 수 있는지가 중요하다.

      일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다.
      하지만 코딩테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서,
      단순히 그리디 알고리즘을 이용해도 최적해가 된다는 것을 이를 추론할 수 있어야 풀리도록 출제된다.
      그리디로 얻은 해가 최적의해가 되는 경우에 한에서 문제가 자주 출제된다.
'''

'''
 예시 문제. 거스름 돈
    당신은 음식점의 계산을 도와주는 점원입니다. 카운터에는 거스름돈으로 사용할 500원, 100원,
    50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때 
    거슬러 주어야할 동전의 최소 개수를 구하세요. 단, 거슬러 줘야할 돈 N은 항상 10의 배수입니다.
 문제 해결 아이디어
    최적의 해를 빠르게 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 주면 된다.
    N원을 거슬러 줘야 할 때, 가장 먼저 500원을 거슬러 줄 수 있을 만큼 거슬러 준다
     - 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러준다.
 예시 : 1,260원
   -> 500원짜리 먼저 2개
   -> 100원 : 2개
   -> 50원 : 1개
   -> 10원 : 1개
 해석 // 정당성 분석
  -> 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 
     다른 해가 나올 수 없기 때문이다.
  -> 만약 800원을 거슬러 주어야 할때 , 화폐단위가 500, 400, 100이라면 그리디를 이용하면 500:1, 100:3
     이지만 최적의 해는 400원 짜리 2개를 거슬러 주는 것이다.
     이처럼, 큰 단위가 작은 단위의 배수가 아니라면 최적의해를 보장할 수 없다
  -> 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이
     정당한지 검토할 수 있어야한다.
'''
print(1e8)
n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array:
    count += n // coin # 전체 n을 coin(array값)으로 나눈 몫
    n %= coin # 나머지

print("동전 개수 : ",count)

'''
    시간 복잡도 
     화폐의 종류가 K라고 할 때, 시간 복잡도는 O(K)이다.
     거슬러줘야하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받는다.
'''


